// Require the MAIA math utilities, due to dependencies in the music utilities
// and also for the maia-util module in general.
exports = require('./util-math');

// Utility.
exports.append_ontimes_to_time_signatures =
  function(time_sigs_array, crotchets_per_bar){
  // Tom Collins 26/2/2015.
  // This function appends ontimes to rows of the time-signature table. Added
  // an optional argument crotchets_per_bar, so that in the event of an
  // anacrusis, the first bar is assigned the correct ontime.

  if (crotchets_per_bar == undefined){
    var ontime = 0;
  }
  else{
    var ontime = -crotchets_per_bar;
  }
  time_sigs_array[0]["ontime"] = ontime;
  var i = 1;
  var n = time_sigs_array.length;
  while (i < n) {
    var c = (time_sigs_array[i]["barNo"] - time_sigs_array[i - 1]["barNo"])*time_sigs_array[i - 1]["topNo"]*
    4/time_sigs_array[i - 1]["bottomNo"];
    var d = time_sigs_array[i - 1]["ontime"] + c;
    time_sigs_array[i]["ontime"] = d;
    i=i+1;
  }
  return time_sigs_array;
};


exports.bar_and_beat_number_of_ontime = function(ontime, time_sigs_array){
  // Tom Collins 17/10/2014.
  // In
  // ontime Number mandatory
  // time_sigs_array Array mandatory
  // Out Array
  // Given an ontime and a time-signature table (with ontimes appended),
  // this function returns the bar number and beat number of that ontime.

  var n = time_sigs_array.length;
  var relevant_row = row_of_max_ontime_leq_ontime_arg(ontime, time_sigs_array);
  if (ontime >= 0) {
    var excess = ontime - relevant_row["ontime"];
    var local_beat_bar = relevant_row["topNo"]*4/relevant_row["bottomNo"];
    var a = [
      relevant_row["barNo"] + Math.floor(excess/local_beat_bar),
      (excess % local_beat_bar) + 1
    ];
  }
  else {
    var anacrusis_beat = time_sigs_array[0]["topNo"] + ontime + 1;
    var a = [0, anacrusis_beat];
  }
  return a;
};


exports.clef_sign_and_line2clef_name =
  function(sign, line, clef_octave_change){
  var lookup = [
    { "sign": "G", "line": 2, "name": "treble clef"},
    { "sign": "G", "line": 2, "clefOctaveChange": 1, "name": "treble clef 8va" },
    { "sign": "G", "line": 2, "clefOctaveChange": 2, "name": "treble clef 15ma" },
    { "sign": "G", "line": 2, "clefOctaveChange": -1, "name": "treble clef 8vb" },
    { "sign": "G", "line": 1, "name": "French violin clef" },
    { "sign": "C", "line": 1, "name": "soprano clef" },
    { "sign": "C", "line": 2, "name": "mezzo-soprano clef" },
    { "sign": "C", "line": 3, "name": "alto clef" },
    { "sign": "C", "line": 4, "name": "tenor clef" },
    { "sign": "C", "line": 4, "name": "baritone clef (C clef)" },
    { "sign": "F", "line": 4, "name": "bass clef" },
    { "sign": "F", "line": 4, "clefOctaveChange": 1, "name": "bass clef 8va" },
    { "sign": "F", "line": 4, "clefOctaveChange": 2, "name": "bass clef 15ma" },
    { "sign": "F", "line": 4, "clefOctaveChange": -1, "name": "bass clef 8vb" },
    { "sign": "F", "line": 4, "clefOctaveChange": -2, "name": "bass clef 15mb" },
    { "sign": "F", "line": 3, "name": "baritone clef (F clef)" },
    { "sign": "F", "line": 5, "name": "subbass clef 15mb" },
    // These last two do not seem to be supported.
    { "sign": "percussion", "line": 2, "name": "percussion clef" },
    { "sign": "TAB", "line": 0, "name": "tablature" }
  ];
  var i = 0;
	while (i < lookup.length){
		if (lookup[i].sign == sign &&
				lookup[i].line == line &&
        (clef_octave_change == undefined ||
         lookup[i].clefOctaveChange &&
         lookup[i].clefOctaveChange == clef_octave_change)){
			var clef_name = lookup[i].name;
      i = lookup.length - 1;
		}
    i++;
	}
	if (clef_name == undefined){
		return "unknown";
	}
	else{
		return clef_name;
	}
}


exports.convert_1st_bar2anacrusis_val = function(bar_1, divisions){
  // Tom Collins 25/2/2015.
  // In
  // bar_1 Object mandatory
  // divisions Integer mandatory
  // Out Array
  // This function works out how long an anacrusis contained in bar_1 should
  // last.

  // Get top and bottom number from time signature, to work out how long a full
  // first bar should last.
  if (bar_1.attributes){
    var attributes = bar_1.attributes;
    for (var j = 0; j < attributes.length; j++){
      if (attributes[j].time){
        // Assuming there is only one time per attribute...
        var time_sig_1 = {};
        time_sig_1.topNo = parseInt(attributes[j].time[0].beats[0]);
        time_sig_1.bottomNo = parseInt(attributes[j].time[0]['beat-type'][0]);
        }
    }
  }
  if (time_sig_1 == undefined) {
    console.log('It was not possible to find a time signature in the first ' +
                'bar of the top staff.');
    console.log('Returning default values for the anacrusis and crotchets '+
                'bar, which may be wrong.');
    return [0, 4];
  }

  var anacrusis = 0;
  var crotchets_per_bar = 4*time_sig_1.topNo/time_sig_1.bottomNo;
  var dur_in_1st_bar_should_be = divisions*crotchets_per_bar;
  var ontime = 0;

  // Get backup value.
  if (bar_1.backup){
    var backups = bar_1.backup;
    }
  else{
    backups = [];
  }

  // Increment over the notes.
  if (bar_1.note){
    var notes = bar_1.note;
    for (note_index = 0; note_index < notes.length; note_index++){
      if (notes[note_index].grace == undefined){
        // This is the integer duration expressed in MusicXML.
        var duration = parseInt(notes[note_index].duration[0]);
        var offtime = ontime + duration;
        // Correct rounding errors in the offtime values.
        // If the note is a second, third, etc. note of a chord, then do
        // not increment the ontime variable.
        if (note_index < notes.length - 1 && notes[note_index + 1].chord){
        }
        else { // Do increment the ontime value.
          ontime = offtime;
        }
      }
    }
  }
  var compar = ontime/(backups.length + 1);
  if (compar != dur_in_1st_bar_should_be){
    anacrusis = -compar/divisions;
  }
  return [anacrusis, crotchets_per_bar];
}


exports.default_page_and_system_breaks =
  function(staff_and_clef_names, final_bar_no){
  // Tom Collins 1/3/2015.
  // In
  // staff_and_clef_names Array mandatory
  // final_bar_no Integer mandatory
  // Out Array
  // If the page_breaks and system_breaks variables are empty, this function
  // will populate them with default values based on the number of staves and
  // bars.

  var page_breaks = [];
  var system_breaks = [];
  var nos_staves = staff_and_clef_names.length;
  switch (nos_staves){
    case 1:
      var sbreak = 4;
      var pbreak = 10*sbreak;
      break;
    case 2:
      var sbreak = 4;
      var pbreak = 5*sbreak;
      break;
    case 3:
      var sbreak = 4;
      var pbreak = 3*sbreak;
      break;
    case 4:
      var sbreak = 4;
      var pbreak = 2*sbreak;
      break;
    case 5:
      var sbreak = 4;
      var pbreak = 2*sbreak;
      break;
    case 6:
      var sbreak = 4;
      var pbreak = 2*sbreak;
      break;
    default:
      var sbreak = 4;
      var pbreak = sbreak;
      break;
  }
  var curr_bar = sbreak;
  while (curr_bar < final_bar_no){
    if (curr_bar%pbreak == 0){
      page_breaks.push(curr_bar + 1);
    }
    else{
      system_breaks.push(curr_bar + 1);
    }
    curr_bar = curr_bar + sbreak;
  }
  return [page_breaks, system_breaks];
}


exports.group_grace_by_contiguous_id = function(grace_array){
  // Tom Collins 18/2/2015.
  // In
  // grace_array Array mandatory
	// An array of grace notes is the input to this function. The function groups
  // these grace notes into new arrays whose membership is determined by
  // contiguity of the id fields. This is to make sure that if several grace
  // notes precede an ordinary note, these are grouped together and (later)
  // attached to this ordinary note.

  var ga = grace_array.sort(sort_points_asc_by_id);
  if (ga.length > 0){
    var gag = [[ga[0]]];
    var gj = 0;
    for (gi = 1; gi < ga.length; gi++){
      if (parseFloat(ga[gi].ID) ==
          parseFloat(gag[gj][gag[gj].length - 1].ID) + 1){
        gag[gj].push(ga[gi]);
      }
      else{
        gag.push([ga[gi]]);
        gj++;
      }
    }
  }
  else{
    var gag = [];
  }
  return gag;
}


function guess_morphetic(mnn, fifth_steps, mode){
  // Tom Collins 15/10/2014.
  // In
  // mnn Integer mandatory
  // fifth_steps Integer mandatory
  // mode Integer mandatory
  // This function takes a MIDI note number and a key (represented by steps on
  // the circle of fiths, and mode). It attempts to guess the corresponding
  // morphetic pitch number, given the key.

  var fifth_steps_lookup_array = new Array;
  fifth_steps_lookup_array = [
    // Major keys.
    [[-6, 0], 6, 4], [[-5, 0], -1, -1],
    [[-4, 0], 4, 2], [[-3, 0], -3, -2],
    [[-2, 0], 2, 1], [[-1, 0], -5, -3],
    [[0, 0], 0, 0], [[1, 0], 5, 3],
    [[2, 0], -2, -1], [[3, 0], 3, 2],
    [[4, 0], -4, -2], [[5, 0], 1, 1],
    [[6, 0], -6, -4],
    // Minor keys.
    [[-3, 5], 6, 4], [[-2, 5], -1, -1],
    [[-1, 5], 4, 2], [[0, 5], -3, -2],
    [[1, 5], 2, 1], [[2, 5], -5, -3],
    [[3, 5], 0, 0], [[4, 5], 5, 3],
    [[5, 5], -2, -1], [[6, 5], 3, 2],
    [[-6, 5], 3, 2], [[7, 5], -4, -2],
    [[-5, 5], -4, -2], [[8, 5], 1, 1],
    [[-4, 5], 1, 1], [[9, 5], -6, -4]
  ];
  var fifth_steps_idx = 0;
  var n = fifth_steps_lookup_array.length;
  var i = 0;
  while (i < n){
    if (fifth_steps == fifth_steps_lookup_array[i][0][0] &&
        mode == fifth_steps_lookup_array[i][0][1]){
      fifth_steps_idx = i;
      i = n - 1;
    }
    i=i+1;
  }
  var trans = fifth_steps_lookup_array[fifth_steps_idx].slice(1);
  var z = mnn + trans[0];
  var w = guess_morphetic_in_C_major(z);
  var a = w - trans[1];
  return a;
};
exports.guess_morphetic = guess_morphetic;


exports.midi_note_morphetic_pair2pitch_and_octave = function(mnn, mpn){
  // Tom Collins 15/10/2014.
  // In
  // mnn Integer mandatory
  // mpn Integer mandatory
  // Out String
  // This function converts a pair consisting of a MIDI note number and a
  // morphetic pitch number into a string consisting of a note's pitch and
  // octave.

  var octave = Math.floor((mpn - 32)/7);
  var midi_residue = mnn - 12*(octave + 1);
  var mpn_residue = mpn - (7*octave + 32);
  var pitch_class_lookup_array = [
    [[12, 6], "B#"], [[0, 0], "C"], [[0, 1], "Dbb"],
    [[13, 6], "B##"], [[1, 0], "C#"], [[1, 1], "Db"],
    [[2, 0], "C##"], [[2, 1], "D"], [[2, 2], "Ebb" ],
    [[3, 1], "D#"], [[3, 2], "Eb"], [[3, 3], "Fbb"],
    [[4, 1], "D##"], [[4, 2], "E"], [[4, 3], "Fb"],
		[[5, 2], "E#"], [[5, 3], "F"], [[5, 4], "Gbb"],
		[[6, 2], "E##"], [[6, 3], "F#"], [[6, 4], "Gb"],
		[[7, 3], "F##"], [[7, 4], "G"], [[7, 5], "Abb"],
		[[8, 4], "G#"], [[8, 5], "Ab"],
		[[9, 4], "G##"], [[9, 5], "A"], [[9, 6], "Bbb"],
		[[-2, 0], "Cbb"], [[10, 5], "A#"], [[10, 6], "Bb"],
    [[11, 5], "A##"], [[11, 6], "B"], [[-1, 0], "Cb"]
  ];
  var pitch_class_idx = undefined;
  var n = pitch_class_lookup_array.length;
  var i = 0;
  while (i < n){
    if (midi_residue == pitch_class_lookup_array[i][0][0] &&
        mpn_residue == pitch_class_lookup_array[i][0][1]){
      pitch_class_idx = i;
      i = n - 1;
    }
    i=i+1;
  }
  var a = pitch_class_lookup_array[pitch_class_idx][1] + octave;
  return a;
};


exports.MNN2pitch_simple = function(MNN){
  // Tom Collins 6/1/2016.
  // In
  // metadata Integer mandatory
  // Out String
  // This function converts a MIDI note number into a pitch class and octave.
  // It does so in a completely naive manner (no consideration of global or
  // local key), but this is handy for things like Tone.js playback, which tend
  // to prefer "C" to "B#", "C#" to "Db" (I think), and "G" to "F##".

  var lookup = [
    "C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"
  ];
  var octave = Math.floor(MNN/12 - 1);
  var MNN_mod_12 = MNN % 12;
  return lookup[MNN_mod_12] + octave.toString();
}


guess_morphetic_in_C_major = function(mnn){
  // Tom Collins 15/10/2014.
  // In
  // mnn Integer mandatory
  // Out Integer
  // This function takes a MIDI note number as its only argument. It
  // attempts to guess the corresponding morphetic pitch number, assuming
  // a key of or close to C major.

  var octave = Math.floor(mnn/12 - 1);
  var midi_residue = mnn - 12*(octave + 1);
  var midi_residue_lookup_array = [
    [0, 0], [1, 0], [2, 1], [3, 2],
    [4, 2], [5, 3], [6, 3], [7, 4],
    [8, 4], [9, 5], [10, 6], [11, 6]
  ];
  var midi_residue_idx = 0;
  var n = midi_residue_lookup_array.length;
  var i = 0;
  while (i < n){
    if (midi_residue == midi_residue_lookup_array[i][0]){
      midi_residue_idx = i;
      i = n - 1;
    }
    i=i+1;
  }
  var mpn_residue = midi_residue_lookup_array[midi_residue_idx][1];
  var a = mpn_residue + 7*octave + 32;
  return a;
};
exports.guess_morphetic_in_C_major = guess_morphetic_in_C_major;


exports.nos_symbols_and_mode2key_name = function(nos_symbols, mode){
  // Tom Collins 19/2/2015.
  // In
  // nos_symbols Integer mandatory
  // mode String mandatory
  // Out String
	// This function takes the number of symbols in a key signature and a string
  // specifying the mode, and converts these pieces of information to a string
  // naming the key signature. For instance, -2 symbols means 2 flats, and
  // aeolian mode would give G aeolian.

  var lookup = [
    { "nosSymbols": 0, "mode": "major", "keyName": "C major" },
    { "nosSymbols": 1, "mode": "major", "keyName": "G major" },
    { "nosSymbols": 2, "mode": "major", "keyName": "D major" },
    { "nosSymbols": 3, "mode": "major", "keyName": "A major" },
    { "nosSymbols": 4, "mode": "major", "keyName": "E major" },
    { "nosSymbols": 5, "mode": "major", "keyName": "B major" },
    { "nosSymbols": 6, "mode": "major", "keyName": "F# major" },
    { "nosSymbols": 7, "mode": "major", "keyName": "C# major" },
    { "nosSymbols": 8, "mode": "major", "keyName": "G# major" },
    { "nosSymbols": 9, "mode": "major", "keyName": "D# major" },
    { "nosSymbols": 10, "mode": "major", "keyName": "A# major" },
    { "nosSymbols": 11, "mode": "major", "keyName": "E# major" },
    { "nosSymbols": -1, "mode": "major", "keyName": "F major" },
    { "nosSymbols": -2, "mode": "major", "keyName": "Bb major" },
    { "nosSymbols": -3, "mode": "major", "keyName": "Eb major" },
    { "nosSymbols": -4, "mode": "major", "keyName": "Ab major" },
    { "nosSymbols": -5, "mode": "major", "keyName": "Db major" },
    { "nosSymbols": -6, "mode": "major", "keyName": "Gb major" },
    { "nosSymbols": -7, "mode": "major", "keyName": "Cb major" },
    { "nosSymbols": -8, "mode": "major", "keyName": "Fb major" },
    { "nosSymbols": -9, "mode": "major", "keyName": "Bbb major" },
    { "nosSymbols": -10, "mode": "major", "keyName": "Ebb major" },
    { "nosSymbols": -11, "mode": "major", "keyName": "Abb major" },
    { "nosSymbols": 0, "mode": "minor", "keyName": "A minor" },
    { "nosSymbols": 1, "mode": "minor", "keyName": "E minor" },
    { "nosSymbols": 2, "mode": "minor", "keyName": "B minor" },
    { "nosSymbols": 3, "mode": "minor", "keyName": "F# minor" },
    { "nosSymbols": 4, "mode": "minor", "keyName": "C# minor" },
    { "nosSymbols": 5, "mode": "minor", "keyName": "G# minor" },
    { "nosSymbols": 6, "mode": "minor", "keyName": "D# minor" },
    { "nosSymbols": 7, "mode": "minor", "keyName": "A# minor" },
    { "nosSymbols": 8, "mode": "minor", "keyName": "E# minor" },
    { "nosSymbols": 9, "mode": "minor", "keyName": "B# minor" },
    { "nosSymbols": 10, "mode": "minor", "keyName": "F## minor" },
    { "nosSymbols": 11, "mode": "minor", "keyName": "C## minor" },
    { "nosSymbols": -1, "mode": "minor", "keyName": "D minor" },
    { "nosSymbols": -2, "mode": "minor", "keyName": "G minor" },
    { "nosSymbols": -3, "mode": "minor", "keyName": "C minor" },
    { "nosSymbols": -4, "mode": "minor", "keyName": "F minor" },
    { "nosSymbols": -5, "mode": "minor", "keyName": "Bb minor" },
    { "nosSymbols": -6, "mode": "minor", "keyName": "Eb minor" },
    { "nosSymbols": -7, "mode": "minor", "keyName": "Ab minor" },
    { "nosSymbols": -8, "mode": "minor", "keyName": "Db minor" },
    { "nosSymbols": -9, "mode": "minor", "keyName": "Gb minor" },
    { "nosSymbols": -10, "mode": "minor", "keyName": "Cb minor" },
    { "nosSymbols": -11, "mode": "minor", "keyName": "Fb minor" },
    { "nosSymbols": 0, "mode": "ionian", "keyName": "C ionian" },
    { "nosSymbols": 1, "mode": "ionian", "keyName": "G ionian" },
    { "nosSymbols": 2, "mode": "ionian", "keyName": "D ionian" },
    { "nosSymbols": 3, "mode": "ionian", "keyName": "A ionian" },
    { "nosSymbols": 4, "mode": "ionian", "keyName": "E ionian" },
    { "nosSymbols": 5, "mode": "ionian", "keyName": "B ionian" },
    { "nosSymbols": 6, "mode": "ionian", "keyName": "F# ionian" },
    { "nosSymbols": 7, "mode": "ionian", "keyName": "C# ionian" },
    { "nosSymbols": 8, "mode": "ionian", "keyName": "G# ionian" },
    { "nosSymbols": 9, "mode": "ionian", "keyName": "D# ionian" },
    { "nosSymbols": 10, "mode": "ionian", "keyName": "A# ionian" },
    { "nosSymbols": 11, "mode": "ionian", "keyName": "E# ionian" },
    { "nosSymbols": -1, "mode": "ionian", "keyName": "F ionian" },
    { "nosSymbols": -2, "mode": "ionian", "keyName": "Bb ionian" },
    { "nosSymbols": -3, "mode": "ionian", "keyName": "Eb ionian" },
    { "nosSymbols": -4, "mode": "ionian", "keyName": "Ab ionian" },
    { "nosSymbols": -5, "mode": "ionian", "keyName": "Db ionian" },
    { "nosSymbols": -6, "mode": "ionian", "keyName": "Gb ionian" },
    { "nosSymbols": -7, "mode": "ionian", "keyName": "Cb ionian" },
    { "nosSymbols": -8, "mode": "ionian", "keyName": "Fb ionian" },
    { "nosSymbols": -9, "mode": "ionian", "keyName": "Bbb ionian" },
    { "nosSymbols": -10, "mode": "ionian", "keyName": "Ebb ionian" },
    { "nosSymbols": -11, "mode": "ionian", "keyName": "Abb ionian" },
    { "nosSymbols": 0, "mode": "dorian", "keyName": "D dorian" },
    { "nosSymbols": 1, "mode": "dorian", "keyName": "A dorian" },
    { "nosSymbols": 2, "mode": "dorian", "keyName": "E dorian" },
    { "nosSymbols": 3, "mode": "dorian", "keyName": "B dorian" },
    { "nosSymbols": 4, "mode": "dorian", "keyName": "F# dorian" },
    { "nosSymbols": 5, "mode": "dorian", "keyName": "C# dorian" },
    { "nosSymbols": 6, "mode": "dorian", "keyName": "G# dorian" },
    { "nosSymbols": 7, "mode": "dorian", "keyName": "D# dorian" },
    { "nosSymbols": 8, "mode": "dorian", "keyName": "A# dorian" },
    { "nosSymbols": 9, "mode": "dorian", "keyName": "E# dorian" },
    { "nosSymbols": 10, "mode": "dorian", "keyName": "B# dorian" },
    { "nosSymbols": 11, "mode": "dorian", "keyName": "F## dorian" },
    { "nosSymbols": -1, "mode": "dorian", "keyName": "G dorian" },
    { "nosSymbols": -2, "mode": "dorian", "keyName": "C dorian" },
    { "nosSymbols": -3, "mode": "dorian", "keyName": "F dorian" },
    { "nosSymbols": -4, "mode": "dorian", "keyName": "Bb dorian" },
    { "nosSymbols": -5, "mode": "dorian", "keyName": "Eb dorian" },
    { "nosSymbols": -6, "mode": "dorian", "keyName": "Ab dorian" },
    { "nosSymbols": -7, "mode": "dorian", "keyName": "Db dorian" },
    { "nosSymbols": -8, "mode": "dorian", "keyName": "Gb dorian" },
    { "nosSymbols": -9, "mode": "dorian", "keyName": "Cb dorian" },
    { "nosSymbols": -10, "mode": "dorian", "keyName": "Fb dorian" },
    { "nosSymbols": -11, "mode": "dorian", "keyName": "Bbb dorian" },
    { "nosSymbols": 0, "mode": "phrygian", "keyName": "E phrygian" },
    { "nosSymbols": 1, "mode": "phrygian", "keyName": "B phrygian" },
    { "nosSymbols": 2, "mode": "phrygian", "keyName": "F# phrygian" },
    { "nosSymbols": 3, "mode": "phrygian", "keyName": "C# phrygian" },
    { "nosSymbols": 4, "mode": "phrygian", "keyName": "G# phrygian" },
    { "nosSymbols": 5, "mode": "phrygian", "keyName": "D# phrygian" },
    { "nosSymbols": 6, "mode": "phrygian", "keyName": "A# phrygian" },
    { "nosSymbols": 7, "mode": "phrygian", "keyName": "E# phrygian" },
    { "nosSymbols": 8, "mode": "phrygian", "keyName": "B# phrygian" },
    { "nosSymbols": 9, "mode": "phrygian", "keyName": "F## phrygian" },
    { "nosSymbols": 10, "mode": "phrygian", "keyName": "C## phrygian" },
    { "nosSymbols": 11, "mode": "phrygian", "keyName": "G## phrygian" },
    { "nosSymbols": -1, "mode": "phrygian", "keyName": "A phrygian" },
    { "nosSymbols": -2, "mode": "phrygian", "keyName": "D phrygian" },
    { "nosSymbols": -3, "mode": "phrygian", "keyName": "G phrygian" },
    { "nosSymbols": -4, "mode": "phrygian", "keyName": "C phrygian" },
    { "nosSymbols": -5, "mode": "phrygian", "keyName": "F phrygian" },
    { "nosSymbols": -6, "mode": "phrygian", "keyName": "Bb phrygian" },
    { "nosSymbols": -7, "mode": "phrygian", "keyName": "Eb phrygian" },
    { "nosSymbols": -8, "mode": "phrygian", "keyName": "Ab phrygian" },
    { "nosSymbols": -9, "mode": "phrygian", "keyName": "Db phrygian" },
    { "nosSymbols": -10, "mode": "phrygian", "keyName": "Gb phrygian" },
    { "nosSymbols": -11, "mode": "phrygian", "keyName": "Cb phrygian" },
    { "nosSymbols": 0, "mode": "lydian", "keyName": "F lydian" },
    { "nosSymbols": 1, "mode": "lydian", "keyName": "C lydian" },
    { "nosSymbols": 2, "mode": "lydian", "keyName": "G lydian" },
    { "nosSymbols": 3, "mode": "lydian", "keyName": "D lydian" },
    { "nosSymbols": 4, "mode": "lydian", "keyName": "A lydian" },
    { "nosSymbols": 5, "mode": "lydian", "keyName": "E lydian" },
    { "nosSymbols": 6, "mode": "lydian", "keyName": "B lydian" },
    { "nosSymbols": 7, "mode": "lydian", "keyName": "F# lydian" },
    { "nosSymbols": 8, "mode": "lydian", "keyName": "C# lydian" },
    { "nosSymbols": 9, "mode": "lydian", "keyName": "G# lydian" },
    { "nosSymbols": 10, "mode": "lydian", "keyName": "D# lydian" },
    { "nosSymbols": 11, "mode": "lydian", "keyName": "A# lydian" },
    { "nosSymbols": -1, "mode": "lydian", "keyName": "Bb lydian" },
    { "nosSymbols": -2, "mode": "lydian", "keyName": "Eb lydian" },
    { "nosSymbols": -3, "mode": "lydian", "keyName": "Ab lydian" },
    { "nosSymbols": -4, "mode": "lydian", "keyName": "Db lydian" },
    { "nosSymbols": -5, "mode": "lydian", "keyName": "Gb lydian" },
    { "nosSymbols": -6, "mode": "lydian", "keyName": "Cb lydian" },
    { "nosSymbols": -7, "mode": "lydian", "keyName": "Fb lydian" },
    { "nosSymbols": -8, "mode": "lydian", "keyName": "Bbb lydian" },
    { "nosSymbols": -9, "mode": "lydian", "keyName": "Ebb lydian" },
    { "nosSymbols": -10, "mode": "lydian", "keyName": "Abb lydian" },
    { "nosSymbols": -11, "mode": "lydian", "keyName": "Dbb lydian" },
    { "nosSymbols": 0, "mode": "mixolydian", "keyName": "G mixolydian" },
    { "nosSymbols": 1, "mode": "mixolydian", "keyName": "D mixolydian" },
    { "nosSymbols": 2, "mode": "mixolydian", "keyName": "A mixolydian" },
    { "nosSymbols": 3, "mode": "mixolydian", "keyName": "E mixolydian" },
    { "nosSymbols": 4, "mode": "mixolydian", "keyName": "B mixolydian" },
    { "nosSymbols": 5, "mode": "mixolydian", "keyName": "F# mixolydian" },
    { "nosSymbols": 6, "mode": "mixolydian", "keyName": "C# mixolydian" },
    { "nosSymbols": 7, "mode": "mixolydian", "keyName": "G# mixolydian" },
    { "nosSymbols": 8, "mode": "mixolydian", "keyName": "D# mixolydian" },
    { "nosSymbols": 9, "mode": "mixolydian", "keyName": "A# mixolydian" },
    { "nosSymbols": 10, "mode": "mixolydian", "keyName": "E# mixolydian" },
    { "nosSymbols": 11, "mode": "mixolydian", "keyName": "B# mixolydian" },
    { "nosSymbols": -1, "mode": "mixolydian", "keyName": "C mixolydian" },
    { "nosSymbols": -2, "mode": "mixolydian", "keyName": "F mixolydian" },
    { "nosSymbols": -3, "mode": "mixolydian", "keyName": "Bb mixolydian" },
    { "nosSymbols": -4, "mode": "mixolydian", "keyName": "Eb mixolydian" },
    { "nosSymbols": -5, "mode": "mixolydian", "keyName": "Ab mixolydian" },
    { "nosSymbols": -6, "mode": "mixolydian", "keyName": "Db mixolydian" },
    { "nosSymbols": -7, "mode": "mixolydian", "keyName": "Gb mixolydian" },
    { "nosSymbols": -8, "mode": "mixolydian", "keyName": "Cb mixolydian" },
    { "nosSymbols": -9, "mode": "mixolydian", "keyName": "Fb mixolydian" },
    { "nosSymbols": -10, "mode": "mixolydian", "keyName": "Bbb mixolydian" },
    { "nosSymbols": -11, "mode": "mixolydian", "keyName": "Ebb mixolydian" },
    { "nosSymbols": 0, "mode": "aeolian", "keyName": "A aeolian" },
    { "nosSymbols": 1, "mode": "aeolian", "keyName": "E aeolian" },
    { "nosSymbols": 2, "mode": "aeolian", "keyName": "B aeolian" },
    { "nosSymbols": 3, "mode": "aeolian", "keyName": "F# aeolian" },
    { "nosSymbols": 4, "mode": "aeolian", "keyName": "C# aeolian" },
    { "nosSymbols": 5, "mode": "aeolian", "keyName": "G# aeolian" },
    { "nosSymbols": 6, "mode": "aeolian", "keyName": "D# aeolian" },
    { "nosSymbols": 7, "mode": "aeolian", "keyName": "A# aeolian" },
    { "nosSymbols": 8, "mode": "aeolian", "keyName": "E# aeolian" },
    { "nosSymbols": 9, "mode": "aeolian", "keyName": "B# aeolian" },
    { "nosSymbols": 10, "mode": "aeolian", "keyName": "F## aeolian" },
    { "nosSymbols": 11, "mode": "aeolian", "keyName": "C## aeolian" },
    { "nosSymbols": -1, "mode": "aeolian", "keyName": "D aeolian" },
    { "nosSymbols": -2, "mode": "aeolian", "keyName": "G aeolian" },
    { "nosSymbols": -3, "mode": "aeolian", "keyName": "C aeolian" },
    { "nosSymbols": -4, "mode": "aeolian", "keyName": "F aeolian" },
    { "nosSymbols": -5, "mode": "aeolian", "keyName": "Bb aeolian" },
    { "nosSymbols": -6, "mode": "aeolian", "keyName": "Eb aeolian" },
    { "nosSymbols": -7, "mode": "aeolian", "keyName": "Ab aeolian" },
    { "nosSymbols": -8, "mode": "aeolian", "keyName": "Db aeolian" },
    { "nosSymbols": -9, "mode": "aeolian", "keyName": "Gb aeolian" },
    { "nosSymbols": -10, "mode": "aeolian", "keyName": "Cb aeolian" },
    { "nosSymbols": -11, "mode": "aeolian", "keyName": "Fb aeolian" },
    { "nosSymbols": 0, "mode": "locrian", "keyName": "B locrian" },
    { "nosSymbols": 1, "mode": "locrian", "keyName": "F# locrian" },
    { "nosSymbols": 2, "mode": "locrian", "keyName": "C# locrian" },
    { "nosSymbols": 3, "mode": "locrian", "keyName": "G# locrian" },
    { "nosSymbols": 4, "mode": "locrian", "keyName": "D# locrian" },
    { "nosSymbols": 5, "mode": "locrian", "keyName": "A# locrian" },
    { "nosSymbols": 6, "mode": "locrian", "keyName": "E## locrian" },
    { "nosSymbols": 7, "mode": "locrian", "keyName": "B## locrian" },
    { "nosSymbols": 8, "mode": "locrian", "keyName": "F## locrian" },
    { "nosSymbols": 9, "mode": "locrian", "keyName": "C## locrian" },
    { "nosSymbols": 10, "mode": "locrian", "keyName": "G## locrian" },
    { "nosSymbols": 11, "mode": "locrian", "keyName": "D## locrian" },
    { "nosSymbols": -1, "mode": "locrian", "keyName": "E locrian" },
    { "nosSymbols": -2, "mode": "locrian", "keyName": "A locrian" },
    { "nosSymbols": -3, "mode": "locrian", "keyName": "D locrian" },
    { "nosSymbols": -4, "mode": "locrian", "keyName": "G locrian" },
    { "nosSymbols": -5, "mode": "locrian", "keyName": "C locrian" },
    { "nosSymbols": -6, "mode": "locrian", "keyName": "F locrian" },
    { "nosSymbols": -7, "mode": "locrian", "keyName": "Bb locrian" },
    { "nosSymbols": -8, "mode": "locrian", "keyName": "Eb locrian" },
    { "nosSymbols": -9, "mode": "locrian", "keyName": "Ab locrian" },
    { "nosSymbols": -10, "mode": "locrian", "keyName": "Db locrian" },
    { "nosSymbols": -11, "mode": "locrian", "keyName": "Gb locrian"}
  ];
  var i = 0;
	while (i < lookup.length){
		if (lookup[i].nosSymbols == nos_symbols &&
				lookup[i].mode == mode){
			var key_name = lookup[i].keyName;
      i = lookup.length - 1;
		}
    i++;
	}
	if (key_name == undefined){
		return "not specified";
	}
	else{
		return key_name;
	}
}


exports.ontime_of_bar_and_beat_number = function(bar, beat, time_sigs_array){
  // Tom Collins 17/10/2014.
  // In
  // bar Integer mandatory
  // beat Number mandatory
  // time_sigs_array Array mandatory
  // Out Number
  // Given a bar and beat number, and a time-signature table (with ontimes
  // appended), this function returns the ontime of that bar and beat
  // number.

  var n = time_sigs_array.length;
  var relevant_row = row_of_max_bar_leq_bar_arg(bar, time_sigs_array);
  var excess = bar - relevant_row["barNo"];
  var local_beat_bar = relevant_row["topNo"]*4/relevant_row["bottomNo"];
  var a = relevant_row["ontime"] + excess*local_beat_bar + beat - 1;
  return a;
};


pitch_and_octave2midi_note_morphetic_pair =
  function(pitch_and_octave){
  // Tom Collins 15/10/2014.
  // In
  // pitch_and_octave String mandatory
  // Out Array
  // This function converts a string consisting of a note's pitch and octave
  // into a  pair consisting of a MIDI note number and a morphetic pitch
  // number.

  var length_arg = pitch_and_octave.length;
  var pitch_class = pitch_and_octave.slice(0, length_arg - 1);
  var octave = pitch_and_octave[length_arg - 1];
  var pitch_class_lookup_array = new Array;
  pitch_class_lookup_array = [
    [[12, 6], "B#"], [[0, 0], "C"], [[0, 1], "Dbb"],
    [[13, 6], "B##"], [[1, 0], "C#"], [[1, 1], "Db"],
    [[2, 0], "C##"], [[2, 1], "D"], [[2, 2], "Ebb" ],
    [[3, 1], "D#"], [[3, 2], "Eb"], [[4, 1], "D##"],
    [[4, 2], "E"], [[3, 3], "Fbb"], [[5, 2], "E#"],
    [[5, 3], "F"], [[5, 4], "Gbb"], [[6, 2], "E##"],
    [[6, 3], "F#"], [[6, 4], "Gb"], [[7, 3], "F##"],
    [[7, 4], "G"], [[7, 5], "Abb"], [[8, 4], "G#"],
    [[8, 5], "Ab"], [[9, 4], "G##"], [[9, 5], "A"],
    [[9, 6], "Bbb"], [[-2, 0], "Cbb"],
    [[10, 5], "A#"], [[10, 6], "Bb"],
    [[11, 5], "A##"], [[11, 6], "B"],
    [[-1, 0], "Cb"]
  ];
  var pitch_class_idx = 1;
  var n = pitch_class_lookup_array.length;
  var i = 0;
  while (i < n){
    if (pitch_class == pitch_class_lookup_array[i][1]){
      pitch_class_idx = i;
      i = n - 1;
    }
    i=i+1;
  }
  var midi_mpn_residue = pitch_class_lookup_array[pitch_class_idx][0];
  var a = [];
  a[0] = 12*octave + 12 + midi_mpn_residue[0];
  a[1] = 7*octave + 32 + midi_mpn_residue[1];
  return a;
};
exports.pitch_and_octave2midi_note_morphetic_pair = pitch_and_octave2midi_note_morphetic_pair;


exports.remove_duplicate_clef_changes = function(clef_changes){
  // Tom Collins 23/2/2015.
  // In
  // clef_changes Array mandatory
  // Out Array
  // This function inspects pairs of clef changes. If there is a clef change
  // in bar n, and a clef change to the same clef in bar n + 1, the clef
  // change in bar n is removed because it is probably a cautionary.

  var arr_out = [];
  for (clefi = 0; clefi < clef_changes.length - 1; clefi++){
    if (clef_changes[clefi + 1].barNo != clef_changes[clefi].barNo + 1 ||
        clef_changes[clefi + 1].clef != clef_changes[clefi].clef ||
        clef_changes[clefi + 1].staffNo != clef_changes[clefi].staffNo){
      arr_out.push(clef_changes[clefi]);
    }
  }
  if (clef_changes.length > 0){
    arr_out.push(clef_changes[clef_changes.length - 1]);
  }
  return arr_out;
}


exports.resolve_expressions = function(expressions){
  // Tom Collins 28/2/2015
  // In
  // expressions Array mandatory
  // Out Array
  // When crescendos and diminuendos are expressed as lines (hairpins, wedges),
  // they have a stopping point as well as a starting point. This function
  // locates wedges stops corresponding to wedge starts, and unites the two
  // pieces of information in one array object.

  // Remove all stop wedges from the expressions array.
  var wedge_stops = [];
  var i = expressions.length - 1;
  while (i >= 0){
    if (expressions[i].type.wedge && expressions[i].type.wedge == "stop"){
      wedge_stops.push(expressions[i]);
      expressions.splice(i, 1);
    }
    i--;
  }
  // Loop over the expressions array and associate each wedge with a member of
  // wedge_stops.
  for (j = 0; j < expressions.length; j++){
    if (expressions[j].type.wedge){
      // Find the target index in wedge_stops.
      target_idx = -1;
      var k = 0;
      while (k < wedge_stops.length){
        if (wedge_stops[k].staffNo == expressions[j].staffNo &&
            wedge_stops[k].placement == expressions[j].placement &&
            wedge_stops[k].ontime >= expressions[j].ontime){
          // We found it!
          target_idx = k;
          k = wedge_stops.length - 1;
        }
        k++;
      }
      if (target_idx >= 0){
        // Add some properties to expressions[j].
        expressions[j].barOff = wedge_stops[target_idx].barOn;
        expressions[j].beatOff = wedge_stops[target_idx].beatOn;
        expressions[j].offtime = wedge_stops[target_idx].ontime;
      }
      else{
        console.log('Could not find a stop for wedge: ', expressions[j]);
      }
    }
  }
  return expressions;
}


row_of_max_bar_leq_bar_arg = function(bar, time_sigs_array){
  // Tom Collins 17/10/2014.
  // In
  // bar Integer mandatory
  // time_sigs_array Array mandatory
  // Out Array
  // This function returns the row (in a list of time signatures) of the
  // maximal bar number less than or equal to the bar number argument.

  var bar_out = time_sigs_array[0];
  var i = 0;
  var n = time_sigs_array.length;
  while (i < n) {
    if (bar < time_sigs_array[i]["barNo"]){
      bar_out = time_sigs_array[i - 1];
      i = n - 1;
    }
    else if (bar == time_sigs_array[0]["barNo"]){
      bar_out = time_sigs_array[i];
      i = n - 1;
    }
    else if (i == n - 1){
      bar_out = time_sigs_array[i];
    }
    i=i+1;
  }
  return bar_out;
};
exports.row_of_max_bar_leq_bar_arg = row_of_max_bar_leq_bar_arg;


row_of_max_ontime_leq_ontime_arg = function(ontime, time_sigs_array){
  // Tom Collins 17/10/2014.
  // In
  // ontime Number mandatory
  // time_sigs_array Array mandatory
  // Out Array
  // This function returns the row (in a list of time signatures) of the
  // maximal ontime less than or equal to the ontime argument.

  var ontime_out = time_sigs_array[0];
  var i = 0;
  var n = time_sigs_array.length;
  while (i < n) {
    if (ontime < time_sigs_array[i]["ontime"]){
      ontime_out = time_sigs_array[i - 1];
      i = n - 1;
    }
    else if (ontime == time_sigs_array[0]["ontime"]){
      ontime_out = time_sigs_array[i];
      i = n - 1;
    }
    else if (i == n - 1){
      ontime_out = time_sigs_array[i];
    }
    i=i+1;
  }
  return ontime_out;
};
exports.row_of_max_ontime_leq_ontime_arg = row_of_max_ontime_leq_ontime_arg;


exports.sort_points_asc = function(a, b){
  // Tom Collins 17/11/2014.
  // In
  // a Object mandatory
  // b Object mandatory
  // Out Object
	// A helper function to sort two notes (points) or rests by ascending ontime.
	// If the ontimes match and MNNs are defined, sort by these instead. If these
	// match, sort by staffNo. If these match, sort by voiceNo.

	if (a.ontime != b.ontime){
    return a.ontime - b.ontime;
	}
	if (a.MNN != undefined){
		if (a.MNN != b.MNN){
			return a.MNN - b.MNN;
		}
	}
	if (a.staffNo != b.staffNo){
		return a.staffNo - b.staffNo;
	}
	return a.voiceNo - b.voiceNo;
}


sort_points_asc_by_id = function(a, b){
  // Tom Collins 18/2/2015.
  // In
  // a Object mandatory
  // b Object mandatory
  // Out Object
	// A helper function, to sort two notes (points) or rests ascending by the
  // values in the id field.

  var c = a.ID;
  var d = b.ID;
  if (typeof c == "string"){
    c = parseFloat(c);
  }
  if (typeof d == "string"){
    d = parseFloat(d);
  }
	return c - d;
}
exports.sort_points_asc_by_id = sort_points_asc_by_id;


exports.staff_voice_xml2staff_voice_json =
  function(voice_no_from_xml, staff_nos_for_this_id, part_idx){
  // Tom Collins 22/2/2015.
  // In
  // voice_no_from_xml Integer mandatory
  // staff_nos_for_this_id Array mandatory
  // part_idx Integer mandatory
  // Out Array
	// This function converts MusicXML 2.0 voice assignments, which can go beyond
  // 1-4 into 5-8 in order to encode multiple staves within the same part, to
  // json_score voice assignments, which use staff number to encode multiple
  // staves within the same part separately, and a voice number always in the
  // range 0-3.

  if (voice_no_from_xml !== undefined){
    // There is a maximum of four voices per staff. In MusicXML 2.0, voices 5-8
    // are used to encode a second staff in the same part. In a json_score
    // these will have separate staff numbers, and this is handled here. The
    // convention of using voices 5-8 to encode a second staff in the same part
    // is not adhered to by hum2xml.
    var staff_idx = Math.floor((voice_no_from_xml - 1)/4);
    var staffNo = staff_nos_for_this_id[staff_idx];
    var voiceNo = voice_no_from_xml%4 - 1;
  }
  else{
    var staffNo = part_idx;
    var voiceNo = 0;
  }
  return [staffNo, voiceNo];
}


// File conversion.
exports.comp_obj2note_point_set = function(comp_obj){
  // Tom Collins 2/2/2015.
  // In
  // comp_obj Object mandatory
  // Out Array
  // This function iterates over the notes property of a Composition object,
  // and converts the objects found there into a point-set format, with
  // so-called columns for ontime, MNN, MPN, duration, staff number, and
  // velocity in [0, 1].

  var notes = comp_obj.notes;
  var out_array = [];
  //get key signature
  
  for (inote = 0; inote < notes.length; inote++){
    var note = [
      notes[inote].ontime,
      notes[inote].MNN,
      notes[inote].MPN,
      notes[inote].duration,
      //notes[inote].staffNo
    ];
    /*if (notes[inote].acousticDescriptor !== undefined &&
        notes[inote].acousticDescriptor.velocity !== undefined){
      note.push(notes[inote].acousticDescriptor.velocity);
    }
    else{
      note.push(.8);
    }*/
    if (notes[inote].notations !== undefined &&
        notes[inote].notations.technical !== undefined &&
        notes[inote].notations.technical.string !== undefined &&
        notes[inote].notations.technical.fret !== undefined){
        //console.log('notes[inote].notations.technical:',
        //            notes[inote].notations.technical);
      note.push(parseInt(notes[inote].notations.technical.string[0]));
      note.push(parseInt(notes[inote].notations.technical.fret[0]));
    }
    else {
      note.push("no string");
      note.push("no fret");
    }
  
    out_array.push(note);
  }
  return out_array;
}


exports.comp_obj2key = function(comp_obj){
  //function to return key signature
  //@author - Orchi
  var key_sig = comp_obj.keySignatures[0].keyName;
  return key_sig;

}

exports.comp_obj2time = function(comp_obj){
  //function to return time signature
  //@author - Orchi
  var time_sig = comp_obj.timeSignatures[0].topNo;
  return time_sig;
}

exports.split_point_set_by_staff =
function split_point_set_by_staff(point_set, staff_idx){
  // Tom Collins 2/2/2015.
  // In
  // point_set Array mandatory
  // staff_idx Integer mandatory
  // Out Array
  // This function splits a point set into multiple point sets, grouping by the
  // values in the (staff_idx)th element.

  // Get the unique staves.
  var staves = [];
  for (ipt = 0; ipt < point_set.length; ipt++){
    staves.push(point_set[ipt][staff_idx]);
  }
  var unq_staves = exports.get_unique(staves).sort(function(a, b){return a - b});
  var out_array = [];
  // Create a point set consisting of points in each staff.
  for (iuq = 0; iuq < unq_staves.length; iuq++){
    var curr_point_set = exports.restrict_point_set_in_nth_to_xs(
      point_set, staff_idx, [unq_staves[iuq]]);
    out_array[iuq] = curr_point_set;

  }
  return out_array;
}


// Keyscape.
// Setup the key profiles.
var key_names = [
  "C major", "Db major", "D major", "Eb major", "E major", "F major",
  "Gb major", "G major", "Ab major", "A major", "Bb major", "B major",
  "C minor", "C# minor", "D minor", "Eb minor", "E minor", "F minor",
  "F# minor", "G minor", "G# minor", "A minor", "Bb minor", "B minor"];
exports.aarden_key_profiles = {};
for (ikey = 0; ikey < 12; ikey++){
  exports.aarden_key_profiles[key_names[ikey]] =
    exports.cyclically_permute_array_by(
    [
      17.77, 0.15, 14.93, 0.16, 19.8, 11.36, 0.29, 22.06, 0.15, 8.15, 0.23,
      4.95
    ],
    -ikey
  );
}
for (ikey = 12; ikey < 24; ikey++){
  exports.aarden_key_profiles[key_names[ikey]] =
    exports.cyclically_permute_array_by(
    [
      18.26, 0.74, 14.05, 16.86, 0.7, 14.44, 0.7, 18.62, 4.57, 1.93, 7.38, 1.76
    ],
    -ikey
  );
}
exports.krumhansl_and_kessler_key_profiles = {};
for (ikey = 0; ikey < 12; ikey++){
  exports.krumhansl_and_kessler_key_profiles[key_names[ikey]] =
    exports.cyclically_permute_array_by(
    [
      6.35, 2.23, 3.48, 2.33, 4.38, 4.09, 2.52, 5.19, 2.39, 3.66, 2.29, 2.88
    ],
    -ikey
  );
}
for (ikey = 12; ikey < 24; ikey++){
  exports.krumhansl_and_kessler_key_profiles[key_names[ikey]] =
    exports.cyclically_permute_array_by(
    [
      6.33, 2.68, 3.52, 5.38, 2.6, 3.53, 2.54, 4.75, 3.98, 2.69, 3.34, 3.17
    ],
    -ikey
  );
}


exports.fifth_steps_mode = function(points, key_profiles, MNN_idx, dur_idx){
  // Tom Collins 6/11/2015.
  // In
  // points Array mandatory
  // key_profiles Object mandatory
  // MNN_idx Integer optional
  // dur_idx Integer optional
  // Out Array
  // This function is an implementation of the Krumhansl-Schmuckler key-finding
  // algorithm. It returns a key estimate for the input points, in the format
  // of key name, maximum correlation value, steps on the circle of fifths
  // (e.g., -1 for F major), and mode (e.g., 5 for Aeolian). So for instance,
  // a key estimate of A minor might have output ["A minor", .8, 3, 5].

  if (MNN_idx == undefined){
    MNN_idx = 1;
  }
  if (dur_idx == undefined){
    dur_idx = 2;
  }

  // Copy the points variable.
  var pts = exports.copy_array_object(points);
  // Convert the MNNs to MNNs mod 12.
  for (i = 0; i < pts.length; i++){
    pts[i][MNN_idx] = pts[i][MNN_idx] % 12;
  }
  // Get the MNN12s and durations in an array. Begin by constructing the
  // indicator to pass to orthogonal_projection_not_unique_equalp.
  var indicator = [];
  for (i = 0; i < pts[0].length; i++){
    if (i == MNN_idx || i == dur_idx){
      indicator[i] = 1;
    }
    else{
      indicator[i] = 0;
    }
  }
  var arr = exports.orthogonal_projection_not_unique_equalp(pts, indicator);
  // Form a distribution over the MNN12s, weighted by duration.
  if (dur_idx >= MNN_idx){
    wght_idx = 1;
  }
  else{
    wght_idx = 0;
  }
  var MNN12_and_distbn = exports.count_rows(arr, wght_idx);
  // Convert to a key profile.
  var idxs = [];
  for (i = 0; i < MNN12_and_distbn[0].length; i++){
    idxs.push(MNN12_and_distbn[0][i][0]);
  }
  var kp = [];
  for (i = 0; i < 12; i++){
    kp[i] = 0;
  }
  for (i = 0; i < idxs.length; i++){
    kp[idxs[i]] = MNN12_and_distbn[1][i];
  }

  // Calculate the correlation between the empirical key profile and each of
  // the theoretical key profiles.
  var key_names = Object.keys(key_profiles);
  var r = [];
  for (i = 0; i < 24; i++){
    r[i] = exports.corr(kp, key_profiles[key_names[i]]);
  }

  // Prepare the return in terms of fith steps and mode.
  var corr_and_key = exports.max_argmax(r);
  var quasi_key = corr_and_key[1];
  var steps = [0, -5, 2, -3, 4, -1, 6, 1, -4, 3, -2, 5];
  var mode = 0;
  if (quasi_key >= 12){
    mode = 5;
  }
  return [key_names[quasi_key], corr_and_key[0], steps[quasi_key % 12], mode];
}


exports.tonic_pitch_closest = function(points, key_name){
  // Tom Collins 22/1/2016.
  // In
  // points Array mandatory
  // key_name String mandatory
  // Out Array
  // This function returns the MIDI note and morphetic pitch numbers of the tonic
  // pitch that is closest to the mean of the input point set, whose key
  // (estimate) is specified as the second input argument.

  // Get the pitch class.
  var pitch_class = key_name.split(" ")[0];
  // Create an array of MNN-MPN pairs for this pitch class across the octaves.
  var min_idx = 1;
  if (pitch_class == "A" || pitch_class == "Bb" || pitch_class == "B"){
    min_idx = 0;
  }
  var max_idx = 7;
  if (pitch_class == "C"){
    max_idx = 8;
  }
  var MNN_MPNs = [];
  for (i = min_idx; i <= max_idx; i++){
    var curr_pitch = pitch_class + i.toString();
    MNN_MPNs.push(pitch_and_octave2midi_note_morphetic_pair(curr_pitch));
  }

  var mu = exports.mean(points.map(function(a){
    return a[1];
  }));
  var mnn_mu = MNN_MPNs.map(function(a){
    return Math.abs(a[0] - mu);
  });
  min_idx = exports.min_argmin(mnn_mu);
  return MNN_MPNs[min_idx[1]];
}


// Chord labeling.
exports.chord_templates_pbmin7ths = [
  // Major triads
  [0, 4, 7], [1, 5 ,8], [2, 6, 9], [3, 7, 10], [4, 8, 11], [5 ,9, 0],
  [6, 10, 1], [7, 11, 2], [8, 0, 3], [9, 1, 4], [10, 2, 5], [11, 3, 6],
  // Dominant 7th triads
  [0, 4, 7, 10], [1, 5 ,8, 11], [2, 6, 9, 0], [3, 7, 10, 1],
  [4, 8, 11, 2], [5 ,9, 0, 3], [6, 10, 1, 4], [7, 11, 2, 5],
  [8, 0, 3, 6], [9, 1, 4, 7], [10, 2, 5 ,8], [11, 3, 6, 9],
  // Minor triads
  [0, 3, 7], [1, 4, 8], [2, 5 ,9], [3, 6, 10], [4, 7, 11], [5 ,8, 0],
  [6, 9, 1], [7, 10, 2], [8, 11, 3], [9, 0, 4], [10, 1, 5], [11, 2, 6],
  // Fully diminished 7th
  [0, 3, 6, 9], [1, 4, 7, 10], [2, 5 ,8, 11],
  // Half diminished 7th
  [0, 3, 6, 10], [1, 4, 7, 11], [2, 5 ,8, 0], [3, 6, 9, 1],
  [4, 7, 10, 2], [5 ,8, 11, 3], [6, 9, 0, 4], [7, 10, 1, 5],
  [8, 11, 2, 6], [9, 0, 3, 7], [10, 1, 4, 8], [11, 2, 5 ,9],
  // Diminished triad
  [0, 3, 6], [1, 4, 7], [2, 5 ,8], [3, 6, 9], [4, 7, 10], [5 ,8, 11],
  [6, 9, 0], [7, 10, 1], [8, 11, 2], [9, 0, 3], [10, 1, 4],
  [11, 2, 5],
  // Minor 7th
  [0, 3, 7, 10], [1, 4, 8, 11], [2, 5 ,9, 0], [3, 6, 10, 1],
  [4, 7, 11, 2], [5 ,8, 0, 3], [6, 9, 1, 4], [7, 10, 2, 5],
  [8, 11, 3, 6], [9, 0, 4, 7], [10, 1, 5 ,8], [11, 2, 6, 9]
];
exports.chord_lookup_pbmin7ths = [
  "C major", "Db major", "D major", "Eb major", "E major", "F major",
  "F# major", "G major", "Ab major", "A major", "Bb major", "B major",
  "C 7", "Db 7", "D 7", "Eb 7", "E 7", "F 7",
  "F# 7", "G 7", "Ab 7", "A 7", "Bb 7", "B 7",
  "C minor", "Db minor", "D minor", "Eb minor", "E minor", "F minor",
  "F# minor", "G minor", "Ab minor", "A minor", "Bb minor", "B minor",
  // Because Pardo & Birmingham (2002) only use MIDI note,
  // there is a bit of an issue with diminished 7th chords
  // (next three labels), as you can't tell for instance
  // whether the pitch classes 0, 3, 6, 9 are C Dim 7,
  // D# Dim 7, F# Dim 7, or A Dim 7. In my Lisp
  // implementation, I use the surrounding musical context
  // (including pitch names derived from the combination of
  // MIDI and morphetic pitch numbers) to attempt to resolve
  // any ambiguities, but in this JavaScript implementation, I
  // just assume it's F# Dim 7 (or G Dim 7 or "G# Dim 7
  // respectively).
  "F# Dim 7", "G Dim 7", "G# Dim 7",
  "C half dim 7", "Db half dim 7", "D half dim 7", "Eb half dim 7", "E half dim 7", "F half dim 7",
  "F# half dim 7", "G half dim 7", "Ab half dim 7", "A half dim 7", "Bb half dim 7", "B half dim 7",
  "C dim", "Db dim", "D dim", "Eb dim", "E dim", "F dim",
  "F# dim", "G dim", "Ab dim", "A dim", "Bb dim", "B dim",
  "C minor 7", "Db minor 7", "D minor 7", "Eb minor 7", "E minor 7", "F minor 7",
  "F# minor 7", "G minor 7", "Ab minor 7", "A minor 7", "Bb minor 7", "B minor 7"
];


connect_or_not = function(singlescore, doublescore){
  // Tom Collins 26/10/2011.
  // In
  // singlescore Array mandatory
  // doublescore Integer mandatory
  // Out Boolean
  // This is how Pardo and Birmingham (2002) decide whether to unite two
  // previously separate segments.
  var connected = 0;
  if (doublescore >= singlescore[0] + singlescore[1]){
    connected = 1;
  }
  return(connected);
}
exports.connect_or_not = connect_or_not;


find_segment_against_template = function(segment, template_set){
  // Tom Collins 26/10/2011.
  // In
  // segment Array mandatory
  // template_set Array mandatory
  // This function returns the chord template to which the input segment is
  // best matched, according to Pardo and Birmingham's (2002) scoring function.
  var d = template_set.length;
  var storage = new Array(d);
  for (var k = 0; k < d; k++){
    storage[k] = score_segment_against_template(segment, template_set[k]);
  }
  var mam = exports.max_argmax(storage);
  var k = mam[1];
  outtemplate = { "score": storage[k], "index": k, "vector": template_set[k] };
  return(outtemplate);
}
exports.find_segment_against_template = find_segment_against_template;


exports.HarmAn_forward = function(segments, templates, lookup){
  // Tom Collins 26/10/2011.
  // In
  // segments Array mandatory
  // templates Array mandatory
  // lookup Array mandatory
  // Out Array
  // This function is the forwards HarmAn algorithm of Pardo and Birmingham
  // (2002).
  var L = segments.length;
  var lab = new Array();
  // Predefine some variables.
  var currentfind;
  var currentscore;
  var lastscore;
  var duosegments;
  var combinedfind;
  var combinedscore;
  // Get the score for the very first segment.
  if (L > 0) {
    currentfind = find_segment_against_template(segments[0], templates);
    currentscore = currentfind.score;
  }
  // No testing to be done here, because there is no previous segment with
  // which to combine it, so just add it to lab.
  lab[0]= {
    "ontime": segments[0].ontime, "offtime": segments[0].offtime,
    "points": segments[0].points, "score": currentscore,
    "index": currentfind.index, "name": lookup[currentfind.index]
  };
  var i = 1; // Iterate over the remaining elements of segments.
  var j = 1; // Iterate over entries to lab.
  while (i < L - 1){
    // Get the score from the last segment.
    lastscore = lab[j - 1].score;
    // Get the score from the current segment.
    currentfind = find_segment_against_template(segments[i], templates);
    currentscore = currentfind.score;
    // Get the score from combining the last and current segments.
    duosegments = {
      "ontime": lab[j - 1].ontime, "offtime": segments[i].offtime,
      "points": lab[j - 1].points.concat(segments[i].points)
    };
    combinedfind = find_segment_against_template(duosegments, templates);
    combinedscore = combinedfind.score;

    // The test!
    if (combinedscore < lastscore + currentscore){
      // Label separately.
      lab.push({
        "ontime": segments[i].ontime, "offtime": segments[i].offtime,
        "points": segments[i].points, "score": currentscore,
        "index": currentfind.index, "name": lookup[currentfind.index]
      });
      j++;
    }
    else{
      // Label the combined segment.
      lab.pop();
      lab.push({
        "ontime": duosegments.ontime, "offtime": duosegments.offtime,
        "points": duosegments.points, "score": combinedscore,
        "index": combinedfind.index, "name": lookup[combinedfind.index]
      });
    }
  i++;
  }
  return lab;
}


points_belonging_to_interval = function(point_set, a, b){
  // Tom Collins 25/10/2011.
  // In
  // point_set Array mandatory
  // a Number mandatory
  // b Number mandatory
  // Out Array
  // For a time interval [a, b), this function will return points from the
  // input point_set that sound during the time interval.

  var L = point_set.length;
  var segment = new Array(L);
  var i = 0;
  var j = 0;
  while (i < L) {
    if (point_set[i][0] < b && point_set[i][0] + point_set[i][3] > a) {
      segment[j] = point_set[i];
      j++;
    }
    if (point_set[i][0] >= b) {
      i = L;
    }
    i++;
  }
  return segment.slice(0, j);
}
exports.points_belonging_to_interval = points_belonging_to_interval;


score_segment_against_template = function(segment, template){
  // Tom Collins 26/10/2011.
  // In
  // segment Object mandatory
  // template Array mandatory
  // Out Integer
  // This is Pardo and Birmingham's (2002) scoring function.

  var d = segment.points.length;
  var t = template.length;
  var member = new Array(d);
  for (i = 0; i < d; i++){
    member[i] = segment.points[i][1] % 12;
  }
  var n = 0;
  var m = 0;
  var p = 0;
  for (var i=0; i<t; i++){
    if (member.indexOf(template[i]) === -1){
      m++;
    }
  }
  for (var k=0; k<d; k++){
    if (template.indexOf(member[k]) === -1){
      n++
    }
    else{
      p++;
    }
  }
  return(p - m - n);
}
exports.score_segment_against_template = score_segment_against_template;


var segment = function(point_set){
  // Tom Collins 25/10/2011.
  // In
  // point_set Array mandatory
  // Out Array
  // This function will take a point set as input, calculate the unique ontimes
  // and offtimes, and return collections of notes that sound at each of the
  // unique times. It is a utility function, used by the HarmAn_forward
  // algorithm and various Markov models.

  // Get all the ontimes.
  var L = point_set.length;
  var ontimes = new Array(L);
  for (i = 0; i < L; i++){
    ontimes[i] = point_set[i][0];
  }
  var offtimes = new Array(L);
  for (i = 0; i < L; i++){
    offtimes[i] = point_set[i][0] + point_set[i][3];
  }

  // Calculate the unique times.
  var onofftimes = new Array(L * 2);
  onofftimes = ontimes.concat(offtimes);
  onofftimes.sort(function(a, b){return a-b});
  var uniquetimes = exports.get_unique(onofftimes);

  // For each unique time, find the notes that sound at this time.
  var d = uniquetimes.length;
  var segments = [];
  for (var k = 0; k < d - 1; k++){
    var a = uniquetimes[k];
    var b = uniquetimes[k + 1];
    // Test that this is really a segment, and not an artifact from rounding
    // tuplet on/offtimes.
    if (b - a > .00002){
      segments.push({
        "ontime": a,
        "offtime": b,
        "points": points_belonging_to_interval(point_set, a, b)
      });
    }
  }
  return segments;
}
exports.segment = segment;


module.exports = exports;
