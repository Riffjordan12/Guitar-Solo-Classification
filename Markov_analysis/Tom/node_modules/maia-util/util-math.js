// Array operations.
exports.append_array = function(an_array){
  // Tom Collins 23/12/2014.
  // In
  // an_array Array mandatory
  // Out Array
  // This function removes one level of brackets from an array.
  
  var out_array = an_array.reduce(function(a, b){
    return a.concat(b);
  }, []);
  return out_array;

  // Old version.
  // var out_array = [];
  // for (ia = 0; ia < an_array.length; ia++){
  //   for (ib = 0; ib < an_array[ia].length; ib++){
  //     out_array.push(an_array[ia][ib]);
  //   }
  // }
};


exports.append_array_of_arrays = function(an_array){
  // Tom Collins 9/8/2015.
  // In
  // an_array Array mandatory
  // Out Array
  // In an array of arrays, this function identifies elements that are arrays
  // of arrays, as opposed to arrays whose first element is a string, and
  // removes one structural level from the former type of arrays.

  var out_array = [];
  for (ia = 0; ia < an_array.length; ia++){
    if (typeof an_array[ia][0] == "string") {
      out_array.push(an_array[ia]);
    }
    else{
      for (ib = 0; ib < an_array[ia].length; ib++){
        out_array.push(an_array[ia][ib]);
      }
    }

  }
  return out_array;

  // CDC said the following is the same, but it did not produce the same
  // output:
  // arr = arr.length>1&&arr[0] instanceof Array?arr[0]:arr;
};


exports.array_object_index_of = function(myArray, searchTerm, property){
  // Joe on Stack Overflow 27/12/2014.
  // In
  // myArray Array mandatory
  // searchTerm Boolean, Number, or String mandatory
  // property String mandatory
  // Out Integer
  // In an array of objects, this function locates the index of the object
  // whose specifiable property is set to a specifiable value.
  // http://stackoverflow.com/questions/8668174/indexof-method-in-an-object-array

  for(var i = 0, len = myArray.length; i < len; i++){
    if (myArray[i][property] === searchTerm) return i;
  }
  return -1;
}


exports.array_object_index_of_array =
function (myArray, searchArray, property){
  // Tom Collins 27/1/2015.
  // In
  // myArray Array mandatory
  // searchArray Array mandatory
  // property String mandatory
  // Out Integer
  // In an array of objects, this function locates the index of an array object
  // whose specifiable property is equal to a specifiable array.

  for(var i = 0, len = myArray.length; i < len; i++) {
    if (myArray[i][property].equals(searchArray)) return i;
  }
  return -1;
}



exports.array_sum = function(an_array){
  // Tom Collins 14/3/2015
  // In
  // an_array Array mandatory
  // Out Number
  // Returns the sum of elements of an array.

  return an_array.reduce(function(a, b){
    return a + b;
  }, 0);

  // Old version.
  // var count = 0;
  // for(var i = 0, n = an_array.length; i < n; i++){
  //  count += an_array[i];
  // }
  // return count;
}


function copy_array_object(arr){
  // Tom Collins 21/2/2015.
  // In
  // arr Array mandatory
  // Out Array
  // This function returns an independent copy of an array object.

  var arr2 = JSON.parse(JSON.stringify(arr));
  return arr2;
}
exports.copy_array_object = copy_array_object;


exports.cyclically_permute_array_by = function(arr, m){
  // Tom Collins 6/11/2015.
  // In
  // arr Array mandatory
  // m Non-negative integer mandatory
  // Out Array
  // This function moves the ith element of an array (counting from zero) to
  // the zeroth element in the output array, where i is the second argument.
  // The (i - 1)th element is moved to the last element in the output array,
  // the (i - 2)th element is moved to the penultimate element in the output
  // array, etc.

  m = m % arr.length;
  var arr2 = copy_array_object(arr);
  var arr3 = arr2.slice(0, m);
  var arr4 = arr2.slice(m).concat(arr3);
  return arr4;
}


Array.prototype.equals = function(array){
  // Joe on Stack Overflow 27/12/2014.
  // In
  // array Array mandatory
  // Out Boolean
  // Returns true if two arrays are equal, and false otherwise.
  // http://stackoverflow.com/questions/7837456/comparing-two-arrays-in-javascript

  // If the other array is a falsy value, return.
  if (!array)
  return false;

  // Compare lengths.
  if (this.length != array.length)
  return false;

  for (var i = 0, l=this.length; i < l; i++){
    // Check if we have nested arrays.
    if (this[i] instanceof Array && array[i] instanceof Array){
      // Recurse into the nested arrays.
      if (!this[i].equals(array[i]))
      return false;
    }
    else if (this[i] != array[i]){
      // Warning - two different object instances will never be equal:
      // {x:20} != {x:20}.
      return false;
    }
  }
  return true;
}


Array.prototype.index_item_1st_occurs = function(a){
  // Tom Collins 1/2/2015.
  // In
  // a Array, Boolean, Number, or String mandatory
  // Out Integer
  // Returns the index at which the given argument a firsts occur. It is more
  // robust than indexOf functionality because it will match arguments
  // consisting of arrays, strings, and booleans as well as numbers. It will
  // not match arbitrary objects, however (see second example in testing).

  var typeofa = typeof a;
  var instanceofarraya = a instanceof Array;
  var idx = -1;
  var i = 0;
  while (i < this.length)
  {
    if (typeof this[i] == typeofa){
      if(instanceofarraya && this[i] instanceof Array){
        if (this[i].equals(a)){
          idx = i;
          i = this.length - 1;
        }
      }
      else{
        if (this[i] == a){
          idx = i;
          i = this.length - 1;
        }
      }
    }
    i=i+1;
  }
  return idx;
}


Array.prototype.index_item_1st_doesnt_occur = function(a){
  // Tom Collins 1/2/2015.
  // In
  // a Array, Boolean, Number, or String mandatory
  // Out Integer
  // Returns the index at which the given argument a first does not occur. It
  // is robust in the sense that it will match arguments consisting of arrays,
  // strings, and booleans as well as numbers. It will not match arbitrary
  // objects, however (see second example in testing).

  var typeofa = typeof a;
  var instanceofarraya = a instanceof Array;
  var idx = -1;
  var i = 0;
  while (i < this.length)
  {
    if (!(typeof this[i] == typeofa) ||
          (instanceofarraya && !(this[i] instanceof Array))){
      idx = i;
      i = this.length - 1;
    }
    else{
      if(instanceofarraya && this[i] instanceof Array){
        if (!this[i].equals(a)){
          idx = i;
          i = this.length - 1;
        }
      }
      else{
        if (!(this[i] == a)){
          idx = i;
          i = this.length - 1;
        }
      }
    }
    i=i+1;
  }
  return idx;
}


exports.max_argmax = function(arr){
  // Tom Collins 21/10/2014.
  // In
  // arr Array mandatory
  // Out Array
  // Returns the maximum element in an array and its index (argument).

  var max = arr[0];
  var maxIndex = 0;
  for (var i = 1; i < arr.length; i++) {
    if (arr[i] > max) {
      maxIndex = i;
      max = arr[i];
    }
  }
  return [max, maxIndex];

  // CDC said the following is the same, but it does not retain the index of
  // the maximum element:
  // return arr.reduce(function(a, b){ return a > b?a:b; }, arr[0]);
}


exports.min_argmin = function(arr){
  // Tom Collins 21/10/2014.
  // In
  // arr Array mandatory
  // Out Array
  // Returns the minimum element in an array and its index (argument).

  var min = arr[0];
  var minIndex = 0;
  for (var i = 1; i < arr.length; i++) {
    if (arr[i] < min) {
      minIndex = i;
      min = arr[i];
    }
  }
  return [min, minIndex];

  // CDC said the following is the same, but it does not retain the index of
  // the minimum element:
  // return arr.reduce(function(a, b){ return a < b?a:b; }, arr[0]);
}


exports.multiply_array_by_constant = function(an_array, a_constant){
  // Tom Collins 27/12/2014.
  // In
  // an_array Array mandatory
  // a_constant Number mandatory
  // Out Array
  // Two arguments are supplied to this function: an array and a constant. An
  // array is returned, containing the result of multiplying each element of
  // the input array by the constant.

  return an_array.map(function(a){ return a*a_constant; });

  // Old version.
  // var out_array = [];
  // for (i = 0; i < an_array.length; i++){
  //   out_array.push(a_constant*an_array[i]);
  // }
  // return out_array;
}


// Point-set operations.
function copy_point_set(point_set){
  // Tom Collins 24/11/2014.
  // In
  // point_set Array mandatory
  // Out Array
  // This function returns an independent copy of a point set.

  var E = [];
  point_set.map(function(x){
    E.push(x.slice());
  });
  return E;

  // Old version.
  // var n = point_set.length;
  // var E = new Array(n);
  // var i = 0; // Increment over D and E.
  // while (i < n){
  //   E[i] = point_set[i].slice();
  //   i++;
  // }
  // return E;
}
exports.copy_point_set = copy_point_set;


exports.count_rows = function(point_set, wght_idx){
  // Tom Collins 7/11/2015.
  // In
  // point_set Array mandatory
  // wght_idx Array optional
  // Out Array
  // This function counts rows of the input point set, weighted, if desired, by
  // values in the wght_idx argument.

  // No check on point_set credentials at present...
  if (wght_idx !== undefined && wght_idx < point_set[0].length){
    // Make a copy of the point_set, where wght_idx values are in the final
    // dimension of each point.
    var arr = copy_point_set(point_set);
    var arr2 = [];
    for (i = 0; i < arr.length; i++){
      var curr_rmv = point_set[i][wght_idx];
      // console.log('curr_rmv:');
      // console.log(curr_rmv);
      arr[i].splice(wght_idx, 1);
      // console.log('arr[i]:');
      // console.log(arr[i]);
      arr2.push(arr[i].concat([curr_rmv]));
    }
    // Sort the rows of a copy of the dataset.
    var E = sort_rows(arr2);
    var F = E[0];
    // var g = E[1];
    // Create a new variable that will contain the unique rows of the dataset.
    var k = point_set[0].length - 1;
    var U = [];
    // Create a new variable that will contain the count of each unique row in
    // the original dataset.
    var v = [];
    U[0] = F[0].slice(0, k);
    v[0] = F[0][k];
    var i = 1; // Increment over F and g.
    var j = 1; // Increment over U and v.
    while (i < point_set.length){
      if (F[i].slice(0, k).equals(F[i - 1].slice(0, k))){
        v[j - 1] = v[j - 1] + F[i][k];
      }
      else{
        U[j] = F[i].slice(0, k);
        v[j] = F[i][k];
        j++;
      }
      i++;
    }
  }
  else{
    // Sort the rows of a copy of the dataset.
    var E = sort_rows(point_set);
    var F = E[0];
    // var g = E[1];
    // Create a new variable that will contain the unique rows of the dataset.
    var k = point_set[0].length;
    var U = [];
    // Create a new variable that will contain the count of each unique row in
    // the original dataset.
    var v = [];
    U[0] = F[0];
    v[0] = 1;
    var i = 1; // Increment over F and g.
    var j = 1; // Increment over U and v.
    while (i < point_set.length){
      if (F[i].equals(F[i - 1])){
        v[j - 1]++;
      }
      else{
        U[j] = F[i];
        v[j] = 1;
        j++;
      }
      i++;
    }
  }
  return [U.slice(0, j), v.slice(0, j)];
}


exports.get_unique = function get_unique(arr){
  // Tom Collins 24/11/2014.
  // In
  // arr Array mandatory
  // Out Array
  // This function returns unique elements from the input array. It will not
  // handle nested arrays properly (see unique_rows).

  var a = [];
  for (var i=0, l=arr.length; i<l; i++){
    if (a.indexOf(arr[i]) === -1){
      a.push(arr[i]);
    }
  }
  return a;
}


function index_point_set(point_set){
  // Tom Collins 24/11/2014.
  // In
  // point_set Array mandatory
  // Out Array
  // This function pushes index values to the last element of each point.

  var k = point_set[0].length;
  var n = point_set.length;
  var i = 0; // Increment over point_set.
  while (i < n){
    point_set[i][k] = i;
    i++;
  }
  return point_set;
}
exports.index_point_set = index_point_set;


lex_more = function(u, v, k){
  // Tom Collins 24/11/2014.
  // In
  // u Array mandatory
  // v Array mandatory
  // k Integer optional
  // This function returns 1 if u is more than v, where more than is the
  // lexicographic ordering. It returns -1 otherwise.

  // In general, for two vectors u and v, this function finds the first index
  // i such that u(i) is not equal to v(i). If u(i) is more than v(i), then u
  // is more than v. If v(i) is more than u(i), then v is more than u. In
  // the event that u equals v, u is not more than v.

  if (typeof k === 'undefined') {
    k = u.length;
  }
  // Logical outcome.
  var tf = -1;
  var i = 0; // Increment over u, v.
  while (i < k){
    if (u[i] == v[i]){
      i++;
    }
    else{
      if (u[i] > v[i]){
        tf = 1;
        i = k + 1;
      }
      else{
        i = k + 1;
      }
    }
  }
  return tf;
}
exports.lex_more = lex_more;


exports.restrict_point_set_in_nth_to_xs = function(point_set, n, xs){
  // Tom Collins 24/11/2014.
  // In
  // point_set Array mandatory
  // n Integer mandatory
  // xs Array mandatory
  // Out Array
  // The first argument to this function is an array consisting of numeric
  // arrays of uniform dimension (what I call a point set). We are interested
  // in the nth element of each array, where n is the second argument. A point
  // is retained in the output if its nth value is a member of the array
  // specified by the third argument.

  var point_set_out = [];
  for (ip = 0; ip < point_set.length; ip++){
    if (xs.indexOf(point_set[ip][n]) != -1){
      point_set_out.push(point_set[ip]);
    }
  }
  return point_set_out;
};


function sort_rows(point_set){
  // Tom Collins 24/11/2014.
  // In
  // point_set Array mandatory
  // Out Array
  // The only argument to this function is an array consisting of numeric
  // arrays of uniform dimension (what I call a point set). This function
  // returns the elements in lexicographic order as first argument. As second
  // argument are the indices of each element from the input array.

  // Create an independent copy of the dataset.
  var E = copy_point_set(point_set);
  // Index the copied dataset.
  E = index_point_set(E);
  // Sort the indexed and copied dataset.
  E.sort(lex_more);
  // Create a new variable that will contain just the dataset.
  var k = point_set[0].length;
  var n = point_set.length;
  var F = new Array(n);
  // Create a new variable that will contain just the index.
  var g = new Array(n);
  var i = 0; // Increment over E, F, and g.
  while (i < n){
    F[i] = E[i].slice(0, k);
    g[i] = E[i][k];
    i++;
  }
  return [F, g];
}
exports.sort_rows = sort_rows;


exports.subtract_two_arrays = function(a, b){
  // Tom Collins 27/12/2014.
  // In
  // a Array mandatory
  // b Array mandatory
  // Out Array
  // Subtracts the second array from the first, element-by-element. It is
  // assumed that elements of array arguments are numbers, and the list
  // arguments are of the same length.

  var out_array = [];
  for (i = 0; i < Math.min(a.length, b.length); i++){
    out_array.push(a[i] - b[i]);
  }
  return out_array;
};


exports.unique_rows = function unique_rows(point_set){
  // Tom Collins 16/12/2014.
  // In
  // point_set Array mandatory
  // Out Array
  // The only argument to this function is an array consisting of numeric
  // arrays of uniform dimension (what I call a point set). This function
  // returns the unique elements in lexicographic order as first argument. As
  // second argument are the indices of each element from the input array.

  // Catch empty arrays.
  var n = point_set.length;
  if (n == 0){
    return [[], []];
  }

  // Sort the rows of a copy of the dataset.
  var E = sort_rows(point_set);
  var F = E[0];
  var g = E[1];
  // Create a new variable that will contain the unique rows of the dataset.
  var k = point_set[0].length;
  var U = new Array(n);
  // Create a new variable that will contain the indices of each unique row in
  // the original dataset.
  var v = new Array(n);
  U[0] = F[0];
  v[0] = [g[0]];
  var i = 1; // Increment over F and g.
  var j = 1; // Increment over U and v.
  while (i < n){
    if (F[i].equals(F[i - 1])){
      v[j - 1].push(g[i]);
    }
    else{
      U[j] = F[i];
      v[j] = [g[i]];
      j++;
    }
    i++;
  }
  return [U.slice(0, j), v.slice(0, j)];
}


// Stats sampling.
exports.choose_one = function(arr){
  // Tom Collins 16/10/2014.
  // In
  // arr Array mandatory
  // Out Array, Boolean, Number, or String
  // This function selects an element at random from the input array and
  // returns it.

  if (arr.length > 0){
    var idx = Math.floor((Math.random() * arr.length));
    return arr[idx];
  }
  else{
    return undefined;
  }
}


exports.corr = function(x, y){
  // Tom Collins 8/11/2015.
  // In
  // x Array mandatory
  // y Array mandatory
  // Out Number
  // This function calculates the Pearson product-moment correlation
  // coefficient between the input arrays x and y. It checks that the arrays
  // are of the same length, but does not check that they each consist of
  // numbers, nor for zero divisors (output NaN in both cases).

  var n = x.length;
  if (n !== y.length){
    throw "Error in call to corr: input arrays must be of the same length.";
  }
  else{
    var x_bar = mean(x);
    var y_bar = mean(y);
    var x2 = 0;
    var y2 = 0;
    var xy = 0;
    for (var i = 0; i < x.length; i++){
      x2 += Math.pow(x[i], 2);
      y2 += Math.pow(y[i], 2);
      xy += x[i]*y[i];
    }
    var r = (xy - n*x_bar*y_bar)/
      (Math.sqrt(x2 - n*Math.pow(x_bar, 2))*Math.sqrt(y2 - n*Math.pow(y_bar, 2)));
    return r;
  }
}


exports.get_random_arbitrary = function(min, max){
  // Mozilla 11/2015.
  // In
  // min Number mandatory
  // max Number mandatory
  // Out Number
  // Returns a random number between min (inclusive) and max (exclusive).
  // From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random

  return Math.random() * (max - min) + min;
}


exports.get_random_int = function(min, max){
  // Mozilla 11/2015.
  // In
  // min Integer mandatory
  // max Integer mandatory
  // Out Number
  // Returns a random integer between min (included) and max (excluded).
  // Using Math.round() will give you a non-uniform distribution!
  // From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random

  return Math.floor(Math.random() * (max - min)) + min;
}


exports.get_random_int_inclusive = function(min, max){
  // Mozilla 11/2015.
  // In
  // min Integer mandatory
  // max Integer mandatory
  // Out Number
  // Returns a random integer between min (included) and max (included).
  // Using Math.round() will give you a non-uniform distribution!
  // From https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random

  return Math.floor(Math.random() * (max - min + 1)) + min;
}


function mean(arr){
  // Christian Coulon and Tom Collins 17/10/2014.
  // In
  // arr Array mandatory
  // Out Number
  // This function returns the mean of an input numeric array.

  if (!arr.length){
    return 0;
  }
  else{
    var sum = 0;
    for (var i = 0; i < arr.length; i++){
      sum += arr[i];
    }
    return sum/arr.length;
  }
}
exports.mean = mean;


// Interpolation.
exports.index_1st_element_gt = function(item, an_array){
  // Tom Collins 27/12/2014.
  // In
  // item Number mandatory
  // an_array Array mandatory
  // Out Integer
  // This function takes two arguments: a real number x and an array L of real
  // numbers. It returns the index of the first element of L that is greater
  // than x.

  var idx = 0;
  var jdx = undefined;
  while (idx < an_array.length){
    if (an_array[idx] > item){
      jdx = idx;
      idx = an_array.length;
    }
    idx++;
  }
  return jdx;
};


// Projection.
function lex_less_or_equal_triple(dj, v, di, k){
  // Tom Collins 16/12/2014.
  // In
  // dj Array mandatory
  // v Array mandatory
  // di Array mandatory
  // k Integer optional
  // This function is useful when testing whether dj + v is lexicographically
  // less than or equal to di. It is faster to check each element of dj + v and
  // di in turn, rather than calculate dj + v first.
  //
  // The function returns 1 if dj + v is 'less than' di, where 'less than' is
  // the lexicographic ordering. It returns -1 if dj + v is 'greater than' di,
  // and it returns 0 if dj + v equals di.
  //
  // In general, for two vectors u and w, this function finds the first index i
  // such that u(i) is not equal to w(i). If u(i) is less than w(i), then u is
  // 'less than' w. If w(i) is less than u(i), then w is 'less than' u. The other
  // possible outcome is that u equals w.

  if (k == undefined){
    k = dj.length;
  }
  // Logical outcome.
  var tf = 0;
  // Dimension of vector.
  var s = 0; // Increment over dj and v.
  var e; // Each element of E = dj + v;
  while (s < k){
    e = dj[s] + v[s];
    if (e > di[s]){
      tf = -1;
      s = k;
    }
    else{
      if (e == di[s]){
        s++;
      }
      else{
        tf = 1;
        s = k;
      }
    }
  }
  return tf;
}
exports.lex_less_or_equal_triple = lex_less_or_equal_triple;


exports.orthogonal_projection_not_unique_equalp =
  function(point_set, indicator){
  // Tom Collins 22/12/2014.
  // In
  // point_set Array mandatory
  // indicator Array mandatory
  // Out Array
  // Given a set of vectors (all members of the same n-dimensional vector
  // space), and an n-tuple of zeros and ones indicating a particular
  // orthogonal projection, this function returns the projected set of vectors.

  var set_out = [];
  for (var ip = 0; ip < point_set.length; ip++){
    var curr_point = [];
    for (var id = 0; id < point_set[0].length; id++){
      if (indicator[id] == 1){
        curr_point.push(point_set[ip][id]);
      }
    }
    set_out.push(curr_point);
  }
  return set_out;
}


exports.maximal_translatable_pattern = function(v, D, k, n){
  // Tom Collins 16/12/2014.
  // In
  // v Array mandatory
  // D Array mandatory
  // k Integer mandatory
  // n Integer mandatory
  // Out Array
  // This function calculates the maximal translatable pattern (MTP, Meredith
  // Lemstrom, & Wiggins, 2002) of the vector v in the point set D (containing
  // n k-dimensional points). The MTP P and indices I of datapoints forming the
  // MTP are returned. It is assumed that the point set D is in lexicograhic
  // order.

  var P = new Array(n);
  var I = new Array(n);
  var i = 0; // Increment over D.
  var j = 0; // Increment over E (= to D + v).
  var L = 0; // Increment over P.
  var tf; // Outcome of call to function lexLessOrEqualTriple.
  while (i < n){
    tf = lex_less_or_equal_triple(D[j], v, D[i], k);
    if (tf == -1){
      i++;
    }
    else{
      if (tf == 0){
        P[L] = D[j];
        I[L] = j;
        i++;
        j++;
        L++;
      }
      else{
        j++;
      }
    }
  }
  return [P.slice(0, L), I.slice(0, L)];
}


// String operations.
exports.locations = function(substring, string){
  // Tom Collins 18/2/2016.
  // In
  // substring String mandatory
  // string String mandatory
  // This function is from vcsjones on stackoverflow, for finding the indices
  // of multiple occurrences of a substring in a string. I thought it would be
  // possible to call str.search(e) where e is a regexp with global modifier,
  // but this did not seem to work.
  // http://stackoverflow.com/questions/10710345/finding-all-indexes-of-a-specified-character-within-a-string

  var a=[],i=-1;
  while((i=string.indexOf(substring,i+1)) >= 0) a.push(i);
  return a;
}



exports.my_last_string = function(a_string){
  // Tom Collins 20/9/2015.
  // In
  // a_string String mandatory
  // Out String
  // This function returns the last element of a string as a string.

  if (a_string.length == 0){
    return "";
  }
  else {
    return a_string[a_string.length - 1];
  }
}


exports.string_separated_string2array = function(substring, a_string){
  // Tom Collins 9/8/2015.
  // In
  // substring String mandatory
  // a_string String mandatory
  // Out Array
  // This function converts a string (second argument) interspersed with
  // occurrences of a substring (first argument) into an array, where each
  // element is a string preceding or proceeding the substring.

  var an_array = a_string.split(substring);
  for (i = 0; i < an_array.length; i++){
    an_array[i] = an_array[i].trim();
  }
  return an_array;
}


module.exports = exports;
